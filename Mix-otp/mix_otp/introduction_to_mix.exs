# Introduction to mix

## main tools


# On elixir we use three main tools.
# OTP(Open Telecom Platform) is a set of libraries that ships with earlang. Earlang developers use OTP to build robust, fault-toleran application.
# Mix: is a build tool that ships with Elixir that provides task for creating, compiling, testing, managing aplications and dependencies.
# ExUnit is a test-unit based framework that ships with Elixir

# When install Elixir, we can use an executable script named mix.

mix new name_project --module Module_name

# mix will create a directory name kx with a few files in it
# creating README.md
# creating .formatter.exs
# creating .gitignore
# creating mix.exs
# creating lib
# creating lib/kv.ex
# creating test
# creating test/test_helper.exs
# creating test/kv_test.exs


## Project compilation


#A file named mix.exs was generated inside our new project folder (kv) and its main responsibility is to configure our project

defmodule KV.MixProject do
  use Mix.Project

  def project do
    [
      app: :kv,
      version: "0.1.0",
      elixir: "~> 1.11",
      start_permanent: Mix.env() == :prod,
      deps: deps()
    ]
  end

  # Run "mix help compile.app" to learn about applications
  def application do
    [
      extra_applications: [:logger]
    ]
  end

  # Run "mix help deps" to learn about dependencies
  defp deps do
    [
      # {:dep_from_hexpm, "~> 0.3.0"},
      # {:dep_from_git, git: "https://github.com/elixir-lang/my_dep.git", tag: "0.1.0"},
    ]
  end
end

#Our mix.exs defines two public functions: project, which returns project configuration like the project name and version, and application, which is used to generate an application file.
#There is also a private function named deps, which is invoked from the project function, that defines our project dependencies.

#Mix also generates a file at lib/kv.ex with a module containing exactly one function, called hello:
defmodule KV do
  @moduledoc """
  Documentation for KV.
  """

  @doc """
  Hello world.

  ## Examples

      iex> KV.hello()
      :world

  """
  def hello do
    :world
  end
end

# to compile our project we use mix compile.
#returns: Compiling 1 file (.ex)
#Generated kv app

#The lib/kv.ex file was compiled, an application manifest named kv.app was generated. All compilation artifacts are placed inside the _build directory using the options defined in the mix.exs file
#Once the project is compiled, you can start an iex session inside the project by running the command:
iex -S mix

#While you may start a new session whenever there are changes to the project source code, you can also recompile the project from within iex with the recompile
recompile() #return :ok :noop
#If anything had to be compiled, you see some informative text, and get the :ok atom back, otherwise the function is silent, and returns :noop.



## Running tests


# Mix also generated the appropriate structure for running our project tests. Mix projects usually follow the convention of having a <filename>_test.exs file in the test directory for each file in the lib directory.
defmodule KVTest do
  use ExUnit.Case
  doctest KV

  test "greets the world" do
    assert KV.hello() == :world
  end
end

# Mix also generated a file named test/test_helper.exs which is responsible for setting up the test framework:
# This file will be required by Mix every time before we run our tests. We can run tests with:
mix(test)

# Mix has compiled the source files and generated the application manifest once again. This happens because Mix supports multiple environments, which we will discuss later in this chapter.
# For each failure, ExUnit prints a detailed report, containing the test name with the test case, the code that failed and the values for the left side and right side (rhs) of the == operator.


## Automatic code formatting


# One of the files generated by mix new is the .formatter.exs. Elixir ships with a code formatter that is capable of automatically formatting our codebase according to a consistent style. The formatter is triggered with the mix format task.


## Environments


#Mix provides the concept of “environments”. They allow a developer to customize compilation and other options for specific scenarios. By default, Mix understands three environments:

# :dev - the one in which Mix tasks (like compile) run by default
# :test - used by mix test
# :prod - the one you will use to run your project in production

#The environment applies only to the current project.

#Customization per environment can be done by accessing the Mix.env function in your mix.exs file, which returns the current environment as an atom. That’s what we have used in the :start_permanent options:
def project do
  [
    ...,
    start_permanent: Mix.env() == :prod,
    ...
  ]
end

#Mix will default to the :dev environment, except for the test task that will default to the :test environment. The environment can be changed via the MIX_ENV environment variable:
MIX_ENV=prod mix compile
#Or on Windows:
set "MIX_ENV=prod" && mix compile
